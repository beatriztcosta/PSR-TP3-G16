#!/usr/bin/env python3
import copy
import math

from matplotlib.pyplot import axis

import rospy
import tf2_ros
from geometry_msgs.msg import Twist
from tf2_geometry_msgs import PoseStamped # **Do not use geometry_msgs. Use this instead for PoseStamped
from sensor_msgs.msg import LaserScan, Image, CameraInfo
from gazebo_msgs.srv import DeleteModel, DeleteModelRequest
import cv2
import numpy as np
from cv_bridge import CvBridge
from rospy import ServiceProxy

import numpy as np
import os
import argparse

COLORS = ['red', 'green', 'blue']
PLAYERS = [[color+str(j) for j in range(1,4)] for color in COLORS] 
RGB = [(255,0,0), (0,255,0), (0,0,255)]

RESOLUTION = 12
SAMPLES = 640/12
HALF_SAMPLES = SAMPLES/2



bridge = CvBridge()


def delete_model(mav_sys_id, vehicle_type):
   
    srv = ServiceProxy('/gazebo/delete_model', DeleteModel)

    req = DeleteModelRequest()
    unique_name = vehicle_type + '_' + str(mav_sys_id)
    req.model_name = unique_name

    resp = srv(req)

    if resp.success:
        print(resp.status_message, '(%s)' % unique_name)
        return 0
    else:
        print("failed to delete model [%s]: %s" %
              (unique_name, resp.status_message), file=sys.stderr)
        return 1 


def arrayToImage(imgraw):
    print(type(imgraw))
    #return np.array(imgraw).reshape(-1,3)

class Driver:

    def __init__(self, name, team):

        self.goal = PoseStamped()
        self.goal_active = False
        self.team = team
        
        self.angle = 0
        self.speed = 0

        self.trackers = np.zeros((RESOLUTION*2,))

        self.name = name #rospy.get_name()
        print('My player name is ' + self.name)

        self.publisher_command = rospy.Publisher( '/' + self.name + '/cmd_vel', Twist, queue_size=1)

        self.tf_buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tf_buffer)

        self.timer = rospy.Timer(rospy.Duration(0.1), self.sendCommandCallback)

        self.goal_subscriber = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.goalReceivedCallback)
        self.laser_subscriber = rospy.Subscriber(f"/{name}/scan", LaserScan, self.scanReceivedFallback)
        self.laser_subscriber = rospy.Subscriber(f"/{name}/camera/rgb/image_raw", Image, self.imageReceivedFallback)

        self.camera_info = rospy.wait_for_message(f"/{name}/camera/rgb/camera_info", CameraInfo)
        print(self.camera_info)

    def imageReceivedFallback(self, image):

        image = bridge.imgmsg_to_cv2(image, desired_encoding='bgr8')


        cv2.imshow("image", image)

        lower = np.array([0,0,0]) 
        upper = np.array([15,15,15]) 
        cars = cv2.threshold(cv2.inRange(image, lower, upper), 128, 255, cv2.THRESH_BINARY)[1]
        cv2.imshow("cars", cars)

        

        teamtrackers = []
        for color_idx in range(3):
            values = [0]*RESOLUTION
            lower = np.array([0,0,0]) 
            upper = np.array([10,10,10])
            lower[2-color_idx] = 90
            upper[2-color_idx] = 120
            mask = cv2.threshold(cv2.inRange(image, lower, upper), 128, 255, cv2.THRESH_BINARY)[1]
            #mask = cv2.erode(mask, kernel)
            #mask = cv2.dilate(mask, kernel)
            cv2.imshow("mask"+str(COLORS[color_idx]), mask)
            mask = mask.sum(axis=0)/255
           
            for i in range(640):
                idxsmall = int((i-HALF_SAMPLES)/SAMPLES)
                p = ((i-HALF_SAMPLES)%SAMPLES)/SAMPLES
                if idxsmall>=0:
                    modifier = 0.5+(1-p)*0.5
                    values[idxsmall] += modifier*mask[i]
                idxbig = idxsmall+1
                if idxbig<RESOLUTION:
                    modifier = 0.5+p*0.5
                    values[idxbig] += modifier*mask[i]
            values = np.array(values)/100
            teamtrackers.append(values)
            print(str(COLORS[color_idx]), values)
        
        cv2.waitKey(1)
        self.trackers = np.concatenate([teamtrackers[(self.team+1)%3] - teamtrackers[(self.team-1)%3], teamtrackers[self.team]], axis=0)
        
        print("trackers: ", self.trackers)


    def scanReceivedFallback(self, msg):
        z = 0
        NUM_SENSORS = 15
        RANGE_MIN = -120*math.pi/180 #-120 degrees
        RANGE_MAX = 120*math.pi/180 #120 degrees
   
        sensors = [100]*NUM_SENSORS

        for idx, range in enumerate(msg.ranges):

            if range < 0.1 or range==math.inf:
                continue

            theta = msg.angle_min + msg.angle_increment * idx

            if theta>math.pi:
                theta = min(theta - math.pi*2, 0) 
            
            if theta>=RANGE_MIN and theta<=RANGE_MAX:
                idx = int( NUM_SENSORS*(theta-RANGE_MIN)/(RANGE_MAX-RANGE_MIN) )

                sensors[idx] = min(range, sensors[idx])

            x = range * math.cos(theta)
            y = range * math.sin(theta)
            

        sensors = np.array(sensors)
        sensors = 10/(sensors+1e-5) 
        sensors[sensors<=.5] = 0
        print(sensors)


    def goalReceivedCallback(self, msg):
        # TODO verify is goal is on odom frame
        print('Received new goal on frame id' + msg.header.frame_id)
        target_frame = self.name + '/odom'
        try:

            self.goal = self.tf_buffer.transform(msg, target_frame, rospy.Duration(1))
            self.goal_active = True
            rospy.logwarn('Setting new goal')
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            goal_active = False
            rospy.logerr('Could not transform goal from ' + msg.header.frame_id + ' to ' + target_frame + '. Will ignore this goal.')

        # print('Received new goal')
        # self.goal = copy.copy(msg)  # store goal
        # self.goal = copy.copy(msg)  # store goal
        # self.goal_active = True

    def driveStraight(self, minumum_speed=0.1, maximum_speed=1.5):
        goal_copy = copy.deepcopy(self.goal)  # make sure we don't change the stamp field of the goal
        goal_copy.header.stamp = rospy.Time.now()

        # goal_tf = tf2_geometry_msgs.PoseStamped()
        # goal_tf.header.stamp = rospy.Time.now()
        # goal_tf.header.frame_id = self.goal.header.frame_id

        print('Transforming pose')
        goal_in_base_link = self.tf_buffer.transform(goal_copy, self.name + '/base_footprint', rospy.Duration(1))
        print('Pose trasnformed')

        x = goal_in_base_link.pose.position.x
        y = goal_in_base_link.pose.position.y

        self.angle = math.atan2(y,x)

        distance_to_goal = math.sqrt(x**2 + y**2)
        self.speed = max(minumum_speed, 0.5 * distance_to_goal)   # limit minimum speed
        self.speed = min(maximum_speed, self.speed)   # limit maximum speed

    def sendCommandCallback(self, event):
        print('Sending twist command')

        if not self.goal_active:  # no goal, no movement
            self.angle = 0
            self.speed = 0
        else:
            self.driveStraight()

        twist = Twist()
        twist.linear.x = self.speed
        twist.angular.z = self.angle
        self.publisher_command.publish(twist)


def main():
    # ---------------------------------------------------
    # INITIALIZATION
    # ---------------------------------------------------
    #parser = argparse.ArgumentParser()
    #parser.add_argument('-n', '--name', type=str, action='store', required=True,
    #                    help='Assigns the desired name to the driver.')
    #
    #args = vars(parser.parse_args())
    #name = args['name']
    #input()

    rospy.init_node(f"g16_smartdriver", anonymous=False)
    name = rospy.get_name().strip('/')
    print(name)
    myteamidx = max([idx for idx, n in enumerate(COLORS) if name.startswith(n)] or [0])
    print(name, myteamidx)
    print(f"My name is {name}. I am team {COLORS[myteamidx]} I am hunting {PLAYERS[(myteamidx+1)%3]} and fleeing from {PLAYERS[(myteamidx-1)%3]}.")
    driver = Driver(name, myteamidx)
    rospy.spin()

    # ---------------------------------------------------
    # Execution
    # ---------------------------------------------------
    # while not rospy.is_shutdown():
    #
    #     # create a dog message to sent

    # ---------------------------------------------------
    # Termination
    # ---------------------------------------------------


if __name__ == '__main__':
    main()



